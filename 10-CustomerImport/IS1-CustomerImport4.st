Object subclass: #ClassMapping	instanceVariableNames: 'mappedClass mappings tableName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!ClassMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:25'!initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings	mappedClass := aClass.	tableName := aTableName.	mappings := aCollectionOfMappings ! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:40'!map: anObject using: aDataBaseSession	| record |	self toDo: 'se puede optimizar usando array para registros y guardando definicion de tabla una vez'.	record := Dictionary new.		self mapIdOf: anObject into: record using: aDataBaseSession.	self mapEmbededOf: anObject into: record.	"agrego aca el registro y no luego de mapear el id para que lo agrege completo. Lo agrego antes de mapear las rel one to many 	porque si usuara una db de verdad habria foreign key constrain"	aDataBaseSession add: record on: self tableName.	self mapOneToManyRelationshipsOf: anObject using: aDataBaseSession! !!ClassMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 00:42'!unmap: aRecord using: aDataBaseSession	| unMappedObject |	unMappedObject := mappedClass basicNew.	self unmapIdOf: aRecord into: unMappedObject.	self unmap: aRecord into: unMappedObject using: aDataBaseSession.	^ unMappedObject! !!ClassMapping methodsFor: 'table' stamp: 'HernanWilkinson 10/31/2016 23:25'!tableName		^tableName ! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmap: aRecord into: unMappedObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping unmap: aRecord into: unMappedObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	mappings do: [ :aMapping | aMapping mapOneToManyRelationshipsOf: anObject using: aDataBaseSession ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapEmbededOf: anObject into: record	mappings do: [ :aMapping | aMapping embeded: anObject into: record ]! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:43'!unmapIdOf: aRecord into: unMappedObject	unMappedObject instVarNamed: #id put: (aRecord at: #id)! !!ClassMapping methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 00:40'!mapIdOf: anObject into: record using: aDataBaseSession	| newId |	newId := aDataBaseSession newIdFor: anObject.	anObject instVarNamed: #id put: newId.	record at: #id put: newId! !!ClassMapping methodsFor: 'testing' stamp: 'HernanWilkinson 10/31/2016 23:02'!isFor: aClass	^mappedClass = aClass! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!ClassMapping class	instanceVariableNames: ''!!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidTableName: aTableName	aTableName trimBoth isEmpty ifTrue: [ self error: 'Table name can not be empty' ]! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 19:26'!assertValidMappings: aCollectionOfMappings for: aClass 	self toDo: 'Lo mejor seria recolectar todos los erroes de mapeo y no parar en el primero'.	aCollectionOfMappings do: [ :aMapping | aMapping assertIsValidFor: aClass ]	! !!ClassMapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 21:15'!assertHasIdInstanceVariable: aClass 		(aClass hasInstVarNamed: #id) ifFalse: [ self error: ('<1s> has no id instance variable' expandMacrosWith: aClass name) ]! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:23'!withDefaultTableNameFor: aClass mappingAll: aCollectionOfMappings	^self for: aClass into: (self defaultTableNameFor: aClass) mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:24'!for: aClass into: aTableName mappingAll: aCollectionOfMappings	self assertValidTableName: aTableName.	self assertHasIdInstanceVariable: aClass.	self assertValidMappings: aCollectionOfMappings for: aClass.		^self new initializeFor: aClass into: aTableName mappingAll: aCollectionOfMappings		! !!ClassMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:44'!defaultTableNameFor: aClass		^aClass name asString! !Object subclass: #DataBaseSession	instanceVariableNames: 'configuration tables id cache'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!DataBaseSession methodsFor: 'persistance' stamp: 'HernanWilkinson 11/1/2016 01:28'!persist: anObject	| mapper |		self assertInTransaction.	self delay.		mapper := self mapperFor: anObject class.	mapper map: anObject using: self.		self addToCache: anObject ! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 10/31/2016 22:17'!selectAllOfType: aClass 		^self select: [ :anObject | true ] ofType: aClass! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:15'!objectIdentifiedAs: anId ofType: aClass	self assertInTransaction.	self delay.		^ cache at: anId ifAbsentPut: [ self unmapRecordIdentifiedAs: anId ofType: aClass ]! !!DataBaseSession methodsFor: 'selecting' stamp: 'HernanWilkinson 11/1/2016 01:26'!select: aCondition ofType: aClass	| mapper table |	self assertInTransaction.	self delay.		mapper := self mapperFor: aClass.	table := tables at: mapper tableName ifAbsent: [ ^ #() ].		^ table inject: OrderedCollection new into: [ :selected :record | self addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 22:14'!close	self assertIsOpen.		tables := nil! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:37'!assertIsClose		tables isNil ifFalse: [ self error: 'Session must be close' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 11/4/2016 09:52'!shutdown	self assertIsOpen.		tables := nil! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 11/4/2016 09:51'!start	self assertIsClose.		tables := Dictionary new.	! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!assertIsOpen		tables isNil ifTrue: [ self error: 'Session must be open to colaborate with it' ]! !!DataBaseSession methodsFor: 'open/close' stamp: 'HernanWilkinson 10/31/2016 18:36'!open	self assertIsClose.		tables := Dictionary new.	! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:41'!delay	(Delay forMilliseconds: 100) wait! !!DataBaseSession methodsFor: 'persistence - private' stamp: 'HernanWilkinson 10/28/2016 16:35'!defineIdOf: anObject	anObject instVarNamed: 'id' put: (self newIdFor: anObject).! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertNotInTransasction		cache notNil ifTrue: [ self error: 'There is an open transaction already' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!commit		self assertInTransaction.		cache := nil! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:55'!assertInTransaction		cache isNil ifTrue: [ self error: 'There is no transaction currently' ]! !!DataBaseSession methodsFor: 'transaction management' stamp: 'HernanWilkinson 10/31/2016 22:57'!beginTransaction	self assertIsOpen.	self assertNotInTransasction.		cache := WeakKeyDictionary new.	! !!DataBaseSession methodsFor: 'selecting - private' stamp: 'HernanWilkinson 11/1/2016 01:28'!addInto: selected theOnesThatHold: aCondition unmapping: record with: mapper	| recordId aClassInstance |	recordId := self recordId: record.	aClassInstance := cache at: recordId ifAbsent: [ mapper unmap: record using: self ].	(aCondition value: aClassInstance) ifTrue: [ 		self addToCache: aClassInstance.		selected add: aClassInstance ].		^ selected! !!DataBaseSession methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 22:55'!initializeFor: aConfiguration	configuration := aConfiguration.	id := 0.	tables := nil.	cache := nil.! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:27'!addToCache: anObject 	cache at: (self idOf: anObject) put: anObject ! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:06'!relatedIdOwnedBy: anOwner on: table	^ table at: (self idOf: anOwner) ifAbsentPut: [ Set new ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!add: aRecord on: aTableName	| table existingRecord |	table := self tableNamed: aTableName.	existingRecord := table at: (self recordId: aRecord) ifAbsentPut: [ aRecord ].	existingRecord == aRecord ifFalse: [ self error: 'Duplicated primary key' ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:00'!signalRelationAlreadyExistBetween: anOwner and: aRelated 	self error: ('Relation between id <1s> of type <2s> and id <3s> of type <4s> already exist'		expandMacrosWith: (self idOf: anOwner) printString		with: anOwner class name		with: (self idOf: aRelated) printString		with: aRelated class name)! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:05'!assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds	(relatedIds includes: relatedId) ifTrue: [ self signalRelationAlreadyExistBetween: anOwner and: aRelated ]! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:10'!relatedIdsOwnedBy: anOwner forType: aRelatedClass	| relatedIds table |	table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := self relatedIdOwnedBy: anOwner on: table.		^ relatedIds! !!DataBaseSession methodsFor: 'adding - private' stamp: 'HernanWilkinson 11/1/2016 01:03'!addRelated: aRelated ownedBy: anOwner	| relatedIds relatedId |	relatedIds := self relatedIdsOwnedBy: anOwner forType: aRelated class.	relatedId := aRelated instVarNamed: #id.	self assertRelationOwnedBy: anOwner isUniqueFor: aRelated identifiedAs: relatedId in: relatedIds.		relatedIds add: relatedId! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass	| ownerClassMapper relatedClassMapper |		ownerClassMapper := self mapperFor: anOwnerClass.	relatedClassMapper := self mapperFor: aRelatedClass.		^ownerClassMapper tableName,'_', relatedClassMapper tableName asPlural.! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 01:12'!relationTableFor: anOwnerClass relatedTo: aRelatedClass	| relationTableName table |	relationTableName := self relationTableNameOwnedBy: anOwnerClass relatedTo: aRelatedClass.	table := self tableNamed: relationTableName.		^ table! !!DataBaseSession methodsFor: 'tables - private' stamp: 'HernanWilkinson 11/1/2016 00:48'!tableNamed: aTableName	^ tables at: aTableName ifAbsentPut: [ Dictionary new ]! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:16'!unmapRecordIdentifiedAs: anId ofType: aClass	| record table mapper |	mapper := self mapperFor: aClass.	table := self tableNamed: mapper tableName.	record := table at: id ifAbsent: [ self error: ('Object identified as <1s> does not exist' expandMacrosWith: anId printString) ].		^ mapper unmap: record using: self! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:14'!mapperFor: aClass	self toDo: 'se puede mejorar performanco usando un dictionary'.	^configuration		detect: [ :aClassMapper | aClassMapper isFor: aClass ] 		ifNone: [ self error: ('There is no mapper for <1s>' expandMacrosWith: aClass name) ]! !!DataBaseSession methodsFor: 'mapping - private' stamp: 'HernanWilkinson 11/1/2016 01:15'!relatedOfType: aRelatedClass for: anOwner	| table relatedIds |		table := self relationTableFor: anOwner class relatedTo: aRelatedClass.	relatedIds := table at: (self idOf: anOwner) ifAbsent: [ ^#() ].		^relatedIds collect: [ :aRelatedId | self objectIdentifiedAs: aRelatedId ofType: aRelatedClass ]		! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:04'!recordId: aRecord	^aRecord at: #id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 10/28/2016 16:35'!newIdFor: anObject	id := id + 1.	^id! !!DataBaseSession methodsFor: 'id' stamp: 'HernanWilkinson 11/1/2016 01:00'!idOf: anObject	^anObject instVarNamed: #id! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DataBaseSession class	instanceVariableNames: ''!!DataBaseSession class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/28/2016 13:07'!for: aConfiguration	^self new initializeFor: aConfiguration! !Object subclass: #Mapping	instanceVariableNames: 'instanceVariableName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!Mapping methodsFor: 'assertions' stamp: 'HernanWilkinson 11/1/2016 01:31'!assertIsValidFor: aClass 	(aClass hasInstVarNamed: instanceVariableName) ifFalse: [ 		self error: ('Invalid mapping for <1s> in class <2s>' expandMacrosWith: instanceVariableName with: aClass name) ] ! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!unmap: aRecord into: anObject using: aDataBaseSession	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!embeded: anObject into: aRecord	self subclassResponsibility! !!Mapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:26'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	self subclassResponsibility! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Mapping class	instanceVariableNames: ''!!Mapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 01:32'!defaultFieldNameFor: anInstanceVariableName	^anInstanceVariableName asString! !!Mapping class methodsFor: 'assertions' stamp: 'HernanWilkinson 10/31/2016 23:41'!assertValidFieldName: aFieldName	aFieldName trimBoth isEmpty ifTrue: [ self error: 'Field name can not be empty' ]! !Mapping subclass: #EmbededMapping	instanceVariableNames: 'fieldName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!unmap: aRecord into: anObject using: aDataBaseSession 	anObject instVarNamed: instanceVariableName put: (aRecord at: fieldName)! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 23:31'!embeded: anObject into: aRecord	aRecord at: fieldName put: (anObject instVarNamed: instanceVariableName) ! !!EmbededMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:23'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession 		! !!EmbededMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:30'!initializeFor: anInstanceVariableName into: aFieldName	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!EmbededMapping class	instanceVariableNames: ''!!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:30'!for: anInstanceVariableName into: aFieldName	^self new initializeFor: anInstanceVariableName into: aFieldName ! !!EmbededMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:29'!withDefaultFieldNameFor: anInstanceVariableName	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName)! !Mapping subclass: #OneToManyMapping	instanceVariableNames: 'relatedType fieldName'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!OneToManyMapping methodsFor: 'initialization' stamp: 'HernanWilkinson 10/31/2016 23:34'!initializeFor: anInstanceVariableName into: aFieldName ofType: aClass	instanceVariableName := anInstanceVariableName.	fieldName := aFieldName.	relatedType := aClass ! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!unmap: aRecord into: anObject using: aDataBaseSession	| newCollection related |	related := aDataBaseSession relatedOfType: relatedType for: anObject.	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	newCollection addAllNotPersisting: related.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:37'!mapOneToManyRelationshipsOf: anObject using: aDataBaseSession	| oldCollection newCollection |	newCollection := self createRelationCollectionOn: aDataBaseSession ownedBy: anObject.	oldCollection := anObject instVarNamed: instanceVariableName.		newCollection addAll: oldCollection.	anObject instVarNamed: instanceVariableName put: newCollection! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 10/31/2016 21:16'!embeded: anObject into: aRecord	! !!OneToManyMapping methodsFor: 'mapping' stamp: 'HernanWilkinson 11/1/2016 01:35'!createRelationCollectionOn: aDataBaseSession ownedBy: anObject	^ OneToManySet on: aDataBaseSession ownedBy: anObject! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManyMapping class	instanceVariableNames: ''!!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:40'!for: anInstanceVariableName into: aFieldName ofType: aClass	self assertValidFieldName: aFieldName.		^self new initializeFor: anInstanceVariableName into: aFieldName ofType: aClass! !!OneToManyMapping class methodsFor: 'instance creation' stamp: 'HernanWilkinson 10/31/2016 23:32'!withDefaultFieldNameFor: anInstanceVariableName ofType: aClass	^self for: anInstanceVariableName into: (self defaultFieldNameFor: anInstanceVariableName) ofType: aClass! !Set subclass: #OneToManySet	instanceVariableNames: 'session owner'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-PersistanceModel'!!OneToManySet methodsFor: 'initialization' stamp: 'HernanWilkinson 11/1/2016 00:11'!initializeOn: aDataBaseSession ownedBy: anOwner		session := aDataBaseSession.	owner := anOwner ! !!OneToManySet methodsFor: 'removing' stamp: 'HernanWilkinson 10/31/2016 21:35'!remove: anObject ifAbsent: anAbsentBlock	self shouldBeImplemented ! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:03'!addAllNotPersisting: aCollection 		^aCollection do: [ :anObjectToAdd | super add: anObjectToAdd ]! !!OneToManySet methodsFor: 'adding' stamp: 'HernanWilkinson 11/1/2016 00:11'!add: anObject	session persist: anObject.	session addRelated: anObject ownedBy: owner.		super add: anObject.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!OneToManySet class	instanceVariableNames: ''!!OneToManySet class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 00:11'!on: aDataBaseSession ownedBy: anOwner		^self new initializeOn: aDataBaseSession ownedBy: anOwner ! !Object subclass: #Address	instanceVariableNames: 'id streetName streetNumber town zipCode province'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:11'!province	^province! !!Address methodsFor: 'province' stamp: 'HernanWilkinson 10/28/2016 16:08'!province: aProvince 	province := aProvince	! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:07'!town: aTown 	town := aTown! !!Address methodsFor: 'twon' stamp: 'HernanWilkinson 10/28/2016 16:12'!town	^town! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetName: aStreetName 	streetName := aStreetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetName	^streetName ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 13:27'!streetNumber: aStreetNumber 	streetNumber := aStreetNumber ! !!Address methodsFor: 'street' stamp: 'HernanWilkinson 10/28/2016 16:12'!streetNumber	^streetNumber ! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:08'!zipCode: aZipCode 	zipCode := aZipCode! !!Address methodsFor: 'zip code' stamp: 'HernanWilkinson 10/28/2016 16:13'!zipCode	^zipCode! !!Address methodsFor: 'testing' stamp: 'HernanWilkinson 11/1/2016 10:06'!isAt: aStreetName	^streetName = aStreetName ! !Object subclass: #Environment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Environment methodsFor: 'system creation' stamp: 'HernanWilkinson 11/4/2016 09:49'!createCustomerSystem	self subclassResponsibility ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Environment class	instanceVariableNames: ''!!Environment class methodsFor: 'enviroment selection' stamp: 'HernanWilkinson 11/4/2016 09:46'!current		^self allSubclasses 		detect: [ :anEnvironemntClass | anEnvironemntClass isCurrent ]		ifFound: [ :anEnvironmentClass | anEnvironmentClass new ]		ifNone: [ self error: 'No environment detected' ]! !!Environment class methodsFor: 'enviroment selection' stamp: 'HernanWilkinson 11/4/2016 09:49'!isCurrent	self subclassResponsibility ! !Environment subclass: #DevelpmentEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!DevelpmentEnvironment methodsFor: 'as yet unclassified' stamp: 'PabloFromer 7/2/2018 17:15'!createCustomerSystem		^TransientPartySystem new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!DevelpmentEnvironment class	instanceVariableNames: ''!!DevelpmentEnvironment class methodsFor: 'as yet unclassified' stamp: 'HernanWilkinson 11/4/2016 09:47'!isCurrent		^IntegrationEnvironment isCurrent not! !Object subclass: #Importer	instanceVariableNames: 'line readStream record system'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Importer methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/2/2016 10:55'!canImportNextLine	line := readStream nextLine.	^ line notNil! !!Importer methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/2/2016 15:54'!convertLineToRecord	record := line substrings: {$,}.		self assertRecordNotEmpty! !!Importer methodsFor: 'importing - private' stamp: 'PabloFromer 6/29/2018 17:23'!importRecord		self subclassResponsibility.! !!Importer methodsFor: 'importing - private' stamp: 'HernanWilkinson 11/2/2016 15:55'!assertRecordNotEmpty		record isEmpty ifTrue: [ self signalInvalidRecordType ]! !!Importer methodsFor: 'error signal' stamp: 'HernanWilkinson 11/1/2016 17:54'!signalInvalidRecordType	self error: self class invalidRecordTypeErrorDescription! !!Importer methodsFor: 'error signal' stamp: 'PabloFromer 7/2/2018 10:45'!signalInvalidPartyRecord 		self error: self class invalidSupplierRecordErrorDescription ! !!Importer methodsFor: 'error signal' stamp: 'PabloFromer 7/2/2018 12:47'!signalAddressWithoutPartyError		self subclassResponsibility ! !!Importer methodsFor: 'error signal' stamp: 'HernanWilkinson 11/1/2016 18:01'!signalInvalidAddressRecord 		self error: self class invalidAddressRecordErrorDescription ! !!Importer methodsFor: 'importing - private - customer' stamp: 'PabloFromer 7/2/2018 10:35'!assertThereIsPartyForAddress	self newParty isNil ifTrue: [ self signalAddressWithoutPartyError ].	! !!Importer methodsFor: 'importing - private - customer' stamp: 'PabloFromer 7/2/2018 10:48'!assertValidPartyRecordSize		record size ~= self validRecordSize  ifTrue: [ self signalInvalidPartyRecord ].	! !!Importer methodsFor: 'importing - private - customer' stamp: 'PabloFromer 7/2/2018 12:46'!newParty	self subclassResponsibility 	! !!Importer methodsFor: 'instance creation' stamp: 'PabloFromer 7/2/2018 17:22'!buildCustomer|customer|	customer := Customer new.	customer firstName:record second.	customer lastName: record third.	customer identificationType: record fourth.	customer identificationNumber: record fifth.	^customer.! !!Importer methodsFor: 'importing - private - address' stamp: 'HernanWilkinson 11/2/2016 10:55'!isAddressRecord	^ record first = 'A'! !!Importer methodsFor: 'importing - private - address' stamp: 'HernanWilkinson 11/2/2016 10:57'!assertValidAddressRecordSize		record size ~= 6 ifTrue: [ self signalInvalidAddressRecord ].	! !!Importer methodsFor: 'importing - private - address' stamp: 'MarianoBenzo 7/1/2018 23:13'!importAddress	| newAddress |	self assertThereIsPartyForAddress.	self assertValidAddressRecordSize.		newAddress := Address new.	newAddress streetName: record second.	newAddress streetNumber: record third asInteger.	newAddress town: record fourth.	newAddress zipCode: record fifth asInteger.	newAddress province: record sixth.	^ self newParty addAddress: newAddress! !!Importer methodsFor: 'importing' stamp: 'HernanWilkinson 11/1/2016 17:51'!import	[ self canImportNextLine ] whileTrue: [ 		self convertLineToRecord.		self importRecord ]! !!Importer methodsFor: 'initialization' stamp: 'PabloFromer 6/29/2018 17:29'!initializeOn: aReadStream using: aPartySystem	readStream := aReadStream.	system := aPartySystem! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Importer class	instanceVariableNames: ''!!Importer class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/1/2016 17:54'!invalidRecordTypeErrorDescription		^'Invalid record type'! !!Importer class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/1/2016 16:02'!addressWithoutCustomerErrorDescription		^'There is no Customer for the imported address'! !!Importer class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/2/2016 10:51'!invalidCustomerRecordErrorDescription		^'Invalid customer record'! !!Importer class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/1/2016 18:00'!invalidAddressRecordErrorDescription		^'Invalid address record'! !!Importer class methodsFor: 'error descriptions' stamp: 'MarianoBenzo 7/1/2018 20:37'!invalidSupplierRecordErrorDescription		^'Invalid supplier record'! !!Importer class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/4/2016 09:27'!from: aReadStream using: aCustomerSystem	^ self new initializeOn: aReadStream using: aCustomerSystem! !Importer subclass: #CustomerImporter	instanceVariableNames: 'newCustomer'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!CustomerImporter methodsFor: 'importing - private' stamp: 'PabloFromer 6/29/2018 17:23'!importRecord		self isCustomerRecord ifTrue: [ ^self importCustomer ].	self isAddressRecord ifTrue: [ ^self importAddress ].		self signalInvalidRecordType! !!CustomerImporter methodsFor: 'importing - private' stamp: 'PabloFromer 7/2/2018 10:48'!validRecordSize	^ 5! !!CustomerImporter methodsFor: 'error signal' stamp: 'PabloFromer 7/2/2018 10:44'!signalInvalidPartyRecord 		self error: self class invalidCustomerRecordErrorDescription ! !!CustomerImporter methodsFor: 'error signal' stamp: 'PabloFromer 7/2/2018 10:34'!signalAddressWithoutPartyError	self error: self class addressWithoutCustomerErrorDescription.! !!CustomerImporter methodsFor: 'instance creation' stamp: 'MarianoBenzo 7/1/2018 23:12'!newParty	^ newCustomer! !!CustomerImporter methodsFor: 'importing - private - customer' stamp: 'PabloFromer 6/29/2018 17:24'!isCustomerRecord	^ record first = 'C'! !!CustomerImporter methodsFor: 'importing - private - customer' stamp: 'PabloFromer 7/2/2018 17:29'!importCustomer	|customer|	self assertValidPartyRecordSize.	customer := self buildCustomer.	system add: customer.	newCustomer := customer.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!CustomerImporter class	instanceVariableNames: ''!!CustomerImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/1/2016 17:54'!invalidRecordTypeErrorDescription		^'Invalid record type'! !!CustomerImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/1/2016 16:02'!addressWithoutCustomerErrorDescription		^'There is no Customer for the imported address'! !!CustomerImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/1/2016 18:00'!invalidAddressRecordErrorDescription		^'Invalid address record'! !!CustomerImporter class methodsFor: 'error descriptions' stamp: 'HernanWilkinson 11/2/2016 10:51'!invalidCustomerRecordErrorDescription		^'Invalid customer record'! !!CustomerImporter class methodsFor: 'instance creation' stamp: 'HernanWilkinson 11/1/2016 15:40'!from: aReadStream on: aSession	^self new initializeOn: aReadStream on: aSession! !TestCase subclass: #ImporterTest	instanceVariableNames: 'importer system'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!ImporterTest methodsFor: 'testing - supplier' stamp: 'PabloFromer 7/2/2018 17:00'!test06ImportSupplierWithNewCustomers		|supplier|	self importSuppliersFrom: self supplierWithNewCustomersData.	supplier := 	system supplierIdentifiedAs: 'D' numbered: '123'.					self  assert: supplier fullNamed: 'Jose' 	identfiedAs: 'D' withNumber: '123' 	andNumberOfAddresses: 0 andNumberOfCustomers: 2.			self assert: (supplier hasCustomerNamed: 'Pepe' lastName: 'Sanchez' identificationType: 'D' identificationNumber: '9898').	self assert: (supplier hasCustomerNamed: 'Ramon' lastName: 'Gomez' identificationType: 'D' identificationNumber: '1010').! !!ImporterTest methodsFor: 'testing - supplier' stamp: 'PabloFromer 7/2/2018 17:14'!test08ShouldNotAddCustomerToSuplierMarkedAsExistingIfItDoesntExist			|supplier|			self  checkImportingSuppliersFrom: self supplierWithExistingCustomersData shouldRaise: SupplierImporter customerDoesntExistErrorDescription andDo: 		      [supplier := 	system supplierIdentifiedAs: 'D' numbered: '123'.					self assert: supplier fullNamed: 'Jose' identfiedAs: 'D' withNumber: '123' andNumberOfAddresses: 0 andNumberOfCustomers: 0. ].! !!ImporterTest methodsFor: 'testing - supplier' stamp: 'PabloFromer 7/2/2018 17:02'!test09AddExistingCustomerToSupplier		|supplier|		system add: self ramon.		self importSuppliersFrom: self supplierWithExistingCustomersData.	supplier := 	system supplierIdentifiedAs: 'D' numbered: '123'.	self assert: supplier fullNamed: 'Jose' identfiedAs: 'D' withNumber: '123' andNumberOfAddresses: 0 andNumberOfCustomers: 1.	self assert: (supplier hasCustomerNamed: 'Ramon' lastName: 'Gomez' identificationType: 'D' identificationNumber: '1010').		! !!ImporterTest methodsFor: 'testing - supplier' stamp: 'PabloFromer 7/2/2018 13:48'!test01ImportSupplierWithoutAddressOrCustomers	| supplier |	self importSuppliersFrom: self joseSupplierData.	supplier := 	system		supplierIdentifiedAs: 'D'		numbered: '123'.			self		assert: supplier		fullNamed: 'Jose'		identfiedAs: 'D'		withNumber: '123'		andNumberOfAddresses: 0.! !!ImporterTest methodsFor: 'testing - supplier' stamp: 'PabloFromer 7/2/2018 11:15'!test04CanNotImportSupplierRecordWithMoreThanFourFields	self assertSupplierWasNotImportedFrom: self supplierRecordWithMoreThanFourFieldsTestData 		  andCheckErrorTextFor: SupplierImporter invalidSupplierRecordErrorDescription.! !!ImporterTest methodsFor: 'testing - supplier' stamp: 'PabloFromer 7/2/2018 11:20'!test05ShouldNotImportSupplierRecordsStartingWithMoreThanS	self assertSupplierWasNotImportedFrom: self supplierRecordStartingWithMoreThanOneSTestData 		  andCheckErrorTextFor: SupplierImporter invalidRecordTypeErrorDescription.! !!ImporterTest methodsFor: 'testing - supplier' stamp: 'PabloFromer 7/2/2018 11:04'!test02CanNotImportAddressWithoutSupplier					self assertSupplierWasNotImportedFrom: self addressWithoutPartyTestData 		  andCheckErrorTextFor: SupplierImporter addressWithoutSupplierErrorDescription! !!ImporterTest methodsFor: 'testing - supplier' stamp: 'PabloFromer 7/2/2018 11:12'!test03CanNotImportSupplierRecordWithLessThanFourFields	self assertSupplierWasNotImportedFrom: self supplierRecordWithLessThanFourFieldsTestData 		  andCheckErrorTextFor: SupplierImporter invalidSupplierRecordErrorDescription.! !!ImporterTest methodsFor: 'testing - supplier' stamp: 'PabloFromer 7/2/2018 17:14'!test07ShouldNotAddCustomerToSuplierMarkedAsNewIfAlreadyExists		|supplier|		system add: self ramon.	self  checkImportingSuppliersFrom: self supplierWithNewCustomersData shouldRaise: SupplierImporter customerIsNotNewErrorDescription andDo: 		      [supplier := system supplierIdentifiedAs: 'D' numbered: '123'.					self assert: supplier fullNamed: 'Jose' identfiedAs: 'D' withNumber: '123' andNumberOfAddresses: 0 andNumberOfCustomers: 1. 			self assert: (supplier hasCustomerNamed: 'Pepe' lastName: 'Sanchez' identificationType: 'D' identificationNumber: '9898').].				! !!ImporterTest methodsFor: 'testing - supplier' stamp: 'PabloFromer 7/2/2018 11:57'!test06ImportSupplierWithAddresses		self importSuppliersFrom: self supplierWithAddressData.	self assertJoseSupplierWasImportedCorrectly ! !!ImporterTest methodsFor: 'asserting - suppliers' stamp: 'PabloFromer 7/2/2018 17:12'!checkImportingSuppliersFrom: anInputData shouldRaise: anErrorMessage andDo: aClosure		self		should: [ self importSuppliersFrom: anInputData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: anErrorMessage.			aClosure value ]	! !!ImporterTest methodsFor: 'asserting - suppliers' stamp: 'PabloFromer 7/2/2018 11:08'!assertSupplierWasNotImportedFrom: anInputData andCheckErrorTextFor: anErrorMessage	self  checkImportingSuppliersFrom: anInputData			shouldRaise: anErrorMessage	 		andAssert: [self suppliersIsEmpty].! !!ImporterTest methodsFor: 'asserting - suppliers' stamp: 'PabloFromer 7/2/2018 11:09'!checkImportingSuppliersFrom: anInputData shouldRaise: anErrorMessage andAssert: aClosure		self		should: [ self importSuppliersFrom: anInputData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: anErrorMessage.			self assert: aClosure value ]! !!ImporterTest methodsFor: 'asserting - suppliers' stamp: 'PabloFromer 7/2/2018 13:52'!assertJoseSupplierWasImportedCorrectly	| supplier |	supplier := 	system		supplierIdentifiedAs: 'D'		numbered: '123'.			self		assert: supplier		fullNamed: 'Jose'		identfiedAs: 'D'		withNumber: '123'		andNumberOfAddresses: 2.		self assert: supplier hasAddressAt: 'San Martin' number: 3322 in: 'Olivos' zipCode: 1636 province: 'BsAs'.	self assert: supplier hasAddressAt: 'Maipu' number: 888 in: 'Florida' zipCode: 1122 province: 'Buenos Aires'				! !!ImporterTest methodsFor: 'asserting - suppliers' stamp: 'PabloFromer 7/2/2018 14:12'!assert: supplier fullNamed: aFullName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize andNumberOfCustomers: customersSize	self assert: supplier fullName equals: aFullName.	self assert: supplier identificationType equals: idType.	self assert: supplier identificationNumber equals: idNumber.	self assert: supplier numberOfAddresses equals: addressesSize .	self assert: supplier numberOfCustomers equals: customersSize.! !!ImporterTest methodsFor: 'asserting - suppliers' stamp: 'PabloFromer 7/2/2018 14:12'!assert: supplier fullNamed: aFullName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize	self assert: supplier fullNamed: aFullName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize  andNumberOfCustomers: 0. ! !!ImporterTest methodsFor: 'test data - supplier' stamp: 'PabloFromer 7/2/2018 11:18'!alwaysImportedCustomerIdNumber	^ '22333444'! !!ImporterTest methodsFor: 'test data - supplier' stamp: 'PabloFromer 7/2/2018 11:19'!alwaysImportedSupplierIdNumber	^ '123'! !!ImporterTest methodsFor: 'test data - supplier' stamp: 'PabloFromer 7/2/2018 11:14'!supplierRecordWithLessThanFourFieldsTestData		^ ReadStream on: 'S,Jose,D'! !!ImporterTest methodsFor: 'test data - supplier' stamp: 'PabloFromer 7/2/2018 11:33'!supplierWithAddressData	^ ReadStream on: self alwaysImportedSupplierRecord,'A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos Aires'! !!ImporterTest methodsFor: 'test data - supplier' stamp: 'PabloFromer 7/2/2018 11:14'!supplierRecordWithMoreThanFourFieldsTestData		^ ReadStream on: self alwaysImportedSupplierRecord,',x'! !!ImporterTest methodsFor: 'test data - supplier' stamp: 'PabloFromer 7/2/2018 12:14'!supplierWithNewCustomersData	^ ReadStream on: self alwaysImportedSupplierRecord,'NC,Pepe,Sanchez,D,9898NC,Ramon,Gomez,D,1010'! !!ImporterTest methodsFor: 'test data - supplier' stamp: 'PabloFromer 7/2/2018 11:13'!supplierRecordStartingWithMoreThanOneSTestData		^ ReadStream on:'SS,Jose,D,123'! !!ImporterTest methodsFor: 'test data - supplier' stamp: 'PabloFromer 7/2/2018 11:17'!alwaysImportedSupplierRecord	^ 'S,Jose,', self alwaysImportedSupplierIdType, ',', self alwaysImportedSupplierIdNumber ! !!ImporterTest methodsFor: 'test data - supplier' stamp: 'PabloFromer 7/2/2018 15:48'!ramon	|customer|		customer:= Customer new.	customer firstName: 'Ramon'.	customer lastName: 'Gomez'.	customer identificationType: 'D'.	customer identificationNumber: '1010'.		^customer.			! !!ImporterTest methodsFor: 'test data - supplier' stamp: 'PabloFromer 7/2/2018 11:17'!alwaysImportedSupplierIdType	^ 'D'! !!ImporterTest methodsFor: 'test data - supplier' stamp: 'PabloFromer 7/2/2018 16:54'!supplierWithExistingCustomersData	^ ReadStream on: self alwaysImportedSupplierRecord,'EC,D,1010'! !!ImporterTest methodsFor: 'testing' stamp: 'PabloFromer 6/29/2018 17:09'!testEmptyLinesAreRecognizedAsInvalidRecords	self	assertAddressWasNotImportedFrom: self dataWithEmptyLine 		   andCheckErrorTextFor: Importer invalidRecordTypeErrorDescription.! !!ImporterTest methodsFor: 'testing' stamp: 'PabloFromer 7/2/2018 11:04'!testCanNotImportAddressWithoutCustomer						self assertCustomerWasNotImportedFrom: self addressWithoutPartyTestData 		  andCheckErrorTextFor: Importer addressWithoutCustomerErrorDescription! !!ImporterTest methodsFor: 'testing' stamp: 'PabloFromer 6/29/2018 17:09'!testCanNotImportAddressRecordWithLessThanSixFields			self	assertAddressWasNotImportedFrom: self addressRecordWithLessThanSixFieldsTestData 		   andCheckErrorTextFor: Importer invalidAddressRecordErrorDescription! !!ImporterTest methodsFor: 'testing' stamp: 'HernanWilkinson 11/1/2016 15:56'!testImportCustomers	self importCustomersFrom: self validTestData.	self assertImportedCustomersSizeIsCorrect.	self assertPepeSanchezWasImportedCorrectly.	self assertJuanPerezWasImportedCorrectly! !!ImporterTest methodsFor: 'testing' stamp: 'PabloFromer 6/29/2018 17:09'!testCanNotImportCustomerRecordWithLessThanFiveFields	self assertCustomerWasNotImportedFrom: self customerRecordWithLessThanFiveFieldsTestData 		  andCheckErrorTextFor: Importer invalidCustomerRecordErrorDescription.! !!ImporterTest methodsFor: 'testing' stamp: 'PabloFromer 6/29/2018 17:09'!testCanNotImportCustomerRecordWithMoreThanFiveFields	self assertCustomerWasNotImportedFrom: self customerRecordWithMoreThanFiveFieldsTestData 		  andCheckErrorTextFor: Importer invalidCustomerRecordErrorDescription.! !!ImporterTest methodsFor: 'testing' stamp: 'PabloFromer 6/29/2018 17:09'!testShouldNotImportAddressRecordsStartingWithMoreThanA	self	assertAddressWasNotImportedFrom: self addressRecordStartingWithMoreThanOneATestData 		   andCheckErrorTextFor: Importer invalidRecordTypeErrorDescription.	! !!ImporterTest methodsFor: 'testing' stamp: 'PabloFromer 6/29/2018 17:09'!testCanNotImportAddressRecordWithMoreThanSixFields	self	assertAddressWasNotImportedFrom: self addressRecordWithMoreThanSixFieldsTestData 		   andCheckErrorTextFor: Importer invalidAddressRecordErrorDescription 	! !!ImporterTest methodsFor: 'testing' stamp: 'PabloFromer 6/29/2018 17:09'!testShouldNotImportCustomerRecordsStartingWithMoreThanC	self assertCustomerWasNotImportedFrom: self customerRecordStartingWithMoreThanOneCTestData 		  andCheckErrorTextFor: Importer invalidRecordTypeErrorDescription.! !!ImporterTest methodsFor: 'suppliers' stamp: 'PabloFromer 7/2/2018 11:11'!allSuppliers	^ system allSuppliers! !!ImporterTest methodsFor: 'suppliers' stamp: 'PabloFromer 7/2/2018 11:11'!suppliersIsEmpty		^self allSuppliers isEmpty! !!ImporterTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/3/2016 09:10'!assertImportedCustomersSizeIsCorrect	self assert: system allCustomers size equals: 2! !!ImporterTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/3/2016 09:20'!assertPepeSanchezWasImportedCorrectly	| customer |	customer := self alwaysImportedCustomer. 		self assert: customer isNamed: 'Pepe' lastName: 'Sanchez' identfiedAs: self alwaysImportedCustomerIdType withNumber: self alwaysImportedCustomerIdNumber andNumberOfAddresses: 2.	self assert: customer hasAddressAt: 'San Martin' number: 3322 in: 'Olivos' zipCode: 1636 province: 'BsAs'.	self assert: customer hasAddressAt: 'Maipu' number: 888 in: 'Florida' zipCode: 1122 province: 'Buenos Aires'! !!ImporterTest methodsFor: 'asserting' stamp: 'PabloFromer 6/29/2018 15:06'!assertCustomerWasNotImportedFrom: anInputData andCheckErrorTextFor: anErrorMessage	self  checkImportingFrom: anInputData			shouldRaise: anErrorMessage	 		andAssert: [self customersIsEmpty].	! !!ImporterTest methodsFor: 'asserting' stamp: 'PabloFromer 6/29/2018 15:06'!assertAddressWasNotImportedFrom: anInputData andCheckErrorTextFor: anErorMessage 	self  checkImportingFrom: anInputData 			shouldRaise: anErorMessage	 		andAssert: [self alwaysImportedCustomer addressesIsEmpty].	! !!ImporterTest methodsFor: 'asserting' stamp: 'PabloFromer 6/29/2018 15:07'!checkImportingFrom: anInputData shouldRaise: anErrorMessage andAssert: aClosure		self		should: [ self importCustomersFrom: anInputData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: anErrorMessage.			self assert: aClosure value ]	! !!ImporterTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/3/2016 09:21'!assertJuanPerezWasImportedCorrectly	| customer idType idNumber |	idType := 'C'.	idNumber := '23-25666777-9'.	customer := system customerIdentifiedAs: idType numbered: idNumber.	self		assert: customer		isNamed: 'Juan'		lastName: 'Perez'		identfiedAs: idType		withNumber: idNumber		andNumberOfAddresses: 1.	self		assert: customer		hasAddressAt: 'Alem'		number: 1122		in: 'CABA'		zipCode: 1001		province: 'CABA'! !!ImporterTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 11:00'!assert: customer hasAddressAt: streetName number: streetNumber in: town zipCode: zipCode province: province	| address |		address := customer addressAt: streetName ifNone: [ self fail ].	self assert: address streetName equals: streetName.	self assert: address streetNumber equals: streetNumber.	self assert: address town equals: town.	self assert: address zipCode equals: zipCode.	self assert: address province equals: province.	! !!ImporterTest methodsFor: 'asserting' stamp: 'HernanWilkinson 11/1/2016 10:56'!assert: customer isNamed: firstName lastName: lastName identfiedAs: idType withNumber: idNumber andNumberOfAddresses: addressesSize	self assert: customer firstName equals: firstName.	self assert: customer lastName equals: lastName.	self assert: customer identificationType equals: idType.	self assert: customer identificationNumber equals: idNumber.	self assert: customer numberOfAddresses equals: addressesSize .! !!ImporterTest methodsFor: 'asserting' stamp: 'PabloFromer 7/2/2018 17:10'!checkImportingFrom: anInputData shouldRaise: anErrorMessage andDo: aClosure		self		should: [ self importCustomersFrom: anInputData ]		raise: Error - MessageNotUnderstood		withExceptionDo: [ :anError | 			self assert: anError messageText equals: anErrorMessage.			aClosure value ]	! !!ImporterTest methodsFor: 'importing' stamp: 'PabloFromer 7/2/2018 13:50'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	^ system		customerIdentifiedAs: anIdentifycationType		numered: anIdentificationNumber		ifNone: [ ].! !!ImporterTest methodsFor: 'importing' stamp: 'PabloFromer 6/29/2018 18:13'!importSuppliersFrom: inputStream	(SupplierImporter from: inputStream using: system) import! !!ImporterTest methodsFor: 'importing' stamp: 'PabloFromer 6/29/2018 17:13'!importCustomersFrom: inputStream	(CustomerImporter from: inputStream using: system) import! !!ImporterTest methodsFor: 'setup-teardown' stamp: 'PabloFromer 6/29/2018 19:30'!setUp	system := Environment current createCustomerSystem.	system start.	system beginTransaction! !!ImporterTest methodsFor: 'setup-teardown' stamp: 'HernanWilkinson 11/4/2016 09:52'!tearDown	system commit.	system shutdown! !!ImporterTest methodsFor: 'test data' stamp: 'HernanWilkinson 11/2/2016 10:46'!validTestData	^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAsA,Maipu,888,Florida,1122,Buenos AiresC,Juan,Perez,C,23-25666777-9A,Alem,1122,CABA,1001,CABA'! !!ImporterTest methodsFor: 'test data' stamp: 'HernanWilkinson 11/2/2016 15:52'!dataWithEmptyLine		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAs'! !!ImporterTest methodsFor: 'test data' stamp: 'PabloFromer 6/29/2018 18:15'!joseSupplierData	^ ReadStream on: 'S,Jose,D,123'! !!ImporterTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordWithLessThanSixFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636'! !!ImporterTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordStartingWithMoreThanOneATestData		^ ReadStream on: self alwaysImportedCustomerRecord,'AA,San Martin,3322,Olivos,1636,BsAs'! !!ImporterTest methodsFor: 'test data - address' stamp: 'HernanWilkinson 11/2/2016 10:45'!addressRecordWithMoreThanSixFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,'A,San Martin,3322,Olivos,1636,BsAs,y otra cosa'! !!ImporterTest methodsFor: 'test data - address' stamp: 'PabloFromer 7/2/2018 11:04'!addressWithoutPartyTestData		^ ReadStream on: 'A,San Martin,3322,Olivos,1636,BsAs'! !!ImporterTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/1/2016 17:48'!customerRecordStartingWithMoreThanOneCTestData		^ ReadStream on:'CC,Pepe,Sanchez,D,22333444'! !!ImporterTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:50'!customerRecordWithLessThanFiveFieldsTestData		^ ReadStream on: 'C,Pepe,Sanchez,D'! !!ImporterTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:53'!customerRecordWithMoreThanFiveFieldsTestData		^ ReadStream on: self alwaysImportedCustomerRecord,',x'! !!ImporterTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/3/2016 09:21'!alwaysImportedCustomer	| anIdentificationNumber anIdentifycationType |	anIdentifycationType := self alwaysImportedCustomerIdType.	anIdentificationNumber := self alwaysImportedCustomerIdNumber.	^ system		customerIdentifiedAs: anIdentifycationType		numbered: anIdentificationNumber! !!ImporterTest methodsFor: 'test data - customer' stamp: 'PabloFromer 6/29/2018 16:59'!importedSupplier	| anIdentificationNumber anIdentifycationType |	anIdentifycationType := 'D'.	anIdentificationNumber := 123.	^ system		suplierIdentifiedAs: anIdentifycationType		numbered: anIdentificationNumber! !!ImporterTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:47'!alwaysImportedCustomerRecord	^ 'C,Pepe,Sanchez,', self alwaysImportedCustomerIdType, ',', self alwaysImportedCustomerIdNumber ! !!ImporterTest methodsFor: 'test data - customer' stamp: 'HernanWilkinson 11/2/2016 10:46'!alwaysImportedCustomerIdType	^ 'D'! !!ImporterTest methodsFor: 'customers' stamp: 'PabloFromer 6/29/2018 15:14'!allCustomers	^ system allCustomers! !!ImporterTest methodsFor: 'customers' stamp: 'PabloFromer 6/29/2018 15:12'!customersIsEmpty		^self allCustomers isEmpty! !Environment subclass: #IntegrationEnvironment	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!IntegrationEnvironment methodsFor: 'as yet unclassified' stamp: 'PabloFromer 7/2/2018 17:15'!createCustomerSystem		^PersistentPartySystem new! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!IntegrationEnvironment class	instanceVariableNames: ''!!IntegrationEnvironment class methodsFor: 'as yet unclassified' stamp: 'HernanWilkinson 11/4/2016 09:47'!not	self shouldBeImplemented.! !!IntegrationEnvironment class methodsFor: 'testing' stamp: 'PabloFromer 7/2/2018 18:27'!isCurrent		^true! !Object subclass: #Party	instanceVariableNames: 'identificationType identificationNumber addresses'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Party methodsFor: 'double dispatch' stamp: 'PabloFromer 7/2/2018 13:33'!saveOn: aPartySystem	^self subclassResponsibility.! !!Party methodsFor: 'identification' stamp: 'PabloFromer 6/29/2018 17:45'!identificationType: anIdentificationType 	identificationType := anIdentificationType! !!Party methodsFor: 'identification' stamp: 'PabloFromer 6/29/2018 17:47'!isIdentifiedAs: anIdType numbered: anIdNumber 		^identificationType = anIdType and: [ identificationNumber = anIdNumber  ]! !!Party methodsFor: 'identification' stamp: 'PabloFromer 6/29/2018 17:45'!identificationNumber: anIdentificationNumber 	identificationNumber := anIdentificationNumber! !!Party methodsFor: 'identification' stamp: 'PabloFromer 6/29/2018 17:44'!identificationNumber		^identificationNumber ! !!Party methodsFor: 'identification' stamp: 'PabloFromer 6/29/2018 17:45'!identificationType		^identificationType ! !!Party methodsFor: 'initialization' stamp: 'PabloFromer 6/29/2018 17:46'!initialize	super initialize.	addresses := OrderedCollection new.! !!Party methodsFor: 'addresses' stamp: 'PabloFromer 6/29/2018 17:43'!addressAt: aStreetName ifNone: noneClosure 		^addresses detect: [ :anAddress | anAddress isAt: aStreetName ] ifNone: noneClosure ! !!Party methodsFor: 'addresses' stamp: 'PabloFromer 6/29/2018 17:43'!addAddress: anAddress 	addresses add: anAddress ! !!Party methodsFor: 'addresses' stamp: 'PabloFromer 6/29/2018 17:48'!numberOfAddresses		^addresses size! !!Party methodsFor: 'addresses' stamp: 'PabloFromer 6/29/2018 17:43'!addressesIsEmpty		^addresses isEmpty! !!Party methodsFor: 'addresses' stamp: 'PabloFromer 6/29/2018 17:43'!addresses	^ addresses! !Party subclass: #Customer	instanceVariableNames: 'identificationType identificationNumber id firstName lastName addresses'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Customer methodsFor: 'initialization' stamp: 'HernanWilkinson 10/28/2016 13:26'!initialize	super initialize.	addresses := OrderedCollection new.! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!lastName	^lastName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!lastName: aLastName 	lastName := aLastName! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 16:15'!firstName		^firstName ! !!Customer methodsFor: 'name' stamp: 'HernanWilkinson 10/28/2016 13:09'!firstName: aName 	firstName := aName! !!Customer methodsFor: 'double dispatch' stamp: 'PabloFromer 7/2/2018 13:34'!saveOn: aPartySystem	^aPartySystem addCustomer: self.! !Object subclass: #PartySystem	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!PartySystem methodsFor: 'importing' stamp: 'MarianoBenzo 6/27/2018 21:52'!customerIdentifiedAs: anIdentifycationType numered: anIdentificationNumber ifNone: aBlock
	self subclassResponsibility! !!PartySystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:35'!beginTransaction	self subclassResponsibility! !!PartySystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:35'!commit	self subclassResponsibility! !!PartySystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:52'!shutdown	self subclassResponsibility! !!PartySystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:51'!start	self subclassResponsibility! !!PartySystem methodsFor: 'setup-teardown' stamp: 'MarianoBenzo 6/27/2018 22:30'!close
	self subclassResponsibility! !!PartySystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:35'!allCustomers	self subclassResponsibility! !!PartySystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:35'!customersIsEmpty	self subclassResponsibility! !!PartySystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:35'!add: aCustomer	self subclassResponsibility! !!PartySystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:35'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	self subclassResponsibility! !PartySystem subclass: #PersistentPartySystem	instanceVariableNames: 'session'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!PersistentPartySystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:52'!shutdown	session shutdown! !!PersistentPartySystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:51'!start	session start! !!PersistentPartySystem methodsFor: 'initialization' stamp: 'HernanWilkinson 11/3/2016 08:54'!initialize		super initialize.	self initializeSession. ! !!PersistentPartySystem methodsFor: 'initialization' stamp: 'PabloFromer 7/2/2018 14:49'!initializeSession	session := DataBaseSession		for: (Array with: self addressMapping with: self customerMapping with: self supplierMapping)! !!PersistentPartySystem methodsFor: 'importing' stamp: 'PabloFromer 7/2/2018 13:43'!customerIdentifiedAs: anIdentifycationType numered: anIdentificationNumber ifNone: aBlock		^self partyIdentifiedAs: anIdentifycationType  numbered: anIdentificationNumber  withType: Customer ifNone: aBlock.! !!PersistentPartySystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:33'!add: aCustomer	session persist: aCustomer! !!PersistentPartySystem methodsFor: 'customers' stamp: 'PabloFromer 7/2/2018 13:44'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	^self partyIdentifiedAs: anIdentifycationType  numbered: anIdentificationNumber  withType: Customer ifNone: [ self error: 'Zero or more than one customer found' ].! !!PersistentPartySystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/3/2016 09:11'!customersIsEmpty	^ self allCustomers isEmpty! !!PersistentPartySystem methodsFor: 'customers' stamp: 'PabloFromer 7/2/2018 15:06'!partyIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber withType: aType ifNone: aClosure	| partyCollection |	partyCollection := session		select: [ :aCustomer | 			aCustomer identificationType = anIdentifycationType				and: [ aCustomer identificationNumber = anIdentificationNumber ] ]		ofType: aType.	partyCollection size = 1		ifFalse: [aClosure value].	^ partyCollection anyOne! !!PersistentPartySystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:18'!allCustomers	^ session selectAllOfType: Customer! !!PersistentPartySystem methodsFor: 'customers' stamp: 'PabloFromer 7/2/2018 13:44'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber	^self partyIdentifiedAs: anIdentifycationType  numbered: anIdentificationNumber withType: Supplier ifNone: [ self error: 'Zero or more than one supplier found' ].! !!PersistentPartySystem methodsFor: 'customers' stamp: 'PabloFromer 7/2/2018 15:09'!allSuppliers	^ session selectAllOfType: Supplier! !!PersistentPartySystem methodsFor: 'mapping' stamp: 'HernanWilkinson 11/3/2016 08:52'!addressMapping	^ ClassMapping		withDefaultTableNameFor: Address		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #streetName)				with: (EmbededMapping withDefaultFieldNameFor: #streetNumber)				with: (EmbededMapping withDefaultFieldNameFor: #town)				with: (EmbededMapping withDefaultFieldNameFor: #zipCode)				with: (EmbededMapping withDefaultFieldNameFor: #province))! !!PersistentPartySystem methodsFor: 'mapping' stamp: 'PabloFromer 7/2/2018 18:35'!supplierMapping	^ ClassMapping		withDefaultTableNameFor: Supplier		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #fullName)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #customers ofType: Customer))! !!PersistentPartySystem methodsFor: 'mapping' stamp: 'HernanWilkinson 11/3/2016 08:52'!customerMapping	^ ClassMapping		withDefaultTableNameFor: Customer		mappingAll:			(Array				with: (EmbededMapping withDefaultFieldNameFor: #firstName)				with: (EmbededMapping withDefaultFieldNameFor: #lastName)				with: (EmbededMapping withDefaultFieldNameFor: #identificationType)				with: (EmbededMapping withDefaultFieldNameFor: #identificationNumber)				with: (OneToManyMapping withDefaultFieldNameFor: #addresses ofType: Address))! !!PersistentPartySystem methodsFor: 'setup-teardown' stamp: 'MarianoBenzo 6/27/2018 22:31'!close	self session close! !!PersistentPartySystem methodsFor: 'accessing' stamp: 'MarianoBenzo 6/27/2018 21:32'!session	^ session! !!PersistentPartySystem methodsFor: 'accessing' stamp: 'MarianoBenzo 6/27/2018 21:32'!session: anObject	session := anObject! !!PersistentPartySystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:18'!beginTransaction	session beginTransaction! !!PersistentPartySystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:18'!commit	session commit! !Party subclass: #Supplier	instanceVariableNames: 'identificationType identificationNumber id fullName customers addresses'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!Supplier methodsFor: 'customers' stamp: 'PabloFromer 7/2/2018 14:10'!numberOfCustomers	^customers size.	! !!Supplier methodsFor: 'customers' stamp: 'PabloFromer 7/2/2018 14:47'!hasCustomerNamed: aName lastName: aLastName identificationType: anIdentificationType identificationNumber: anIdentificationNumber	^customers anySatisfy:  [ :aCustomer | aCustomer identificationNumber = anIdentificationNumber 			and: [aCustomer identificationType = anIdentificationType						and: [ aCustomer lastName = aLastName 			and: [ aCustomer firstName = aName ]]]].	 	! !!Supplier methodsFor: 'fullname' stamp: 'PabloFromer 6/29/2018 17:48'!fullName		^fullName ! !!Supplier methodsFor: 'fullname' stamp: 'PabloFromer 6/29/2018 17:48'!fullName: aFullName 	fullName := aFullName.! !!Supplier methodsFor: 'adding' stamp: 'PabloFromer 7/2/2018 13:02'!initialize	super initialize.	customers := OrderedCollection new.	! !!Supplier methodsFor: 'adding' stamp: 'PabloFromer 7/2/2018 14:06'!addCustomer: aCustomer	customers add: aCustomer	! !!Supplier methodsFor: 'double disptach' stamp: 'PabloFromer 7/2/2018 13:35'!saveOn: aPartySystem	^aPartySystem addSupplier: self.	! !Importer subclass: #SupplierImporter	instanceVariableNames: 'newSupplier'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!SupplierImporter methodsFor: 'testing' stamp: 'PabloFromer 7/2/2018 16:36'!isExistingCustomerRecord	^ record first = 'EC'		! !!SupplierImporter methodsFor: 'asserting' stamp: 'PabloFromer 7/2/2018 16:16'!assertCustomerIsNewFor: identificationType with: identificationNumber	system customerIdentifiedAs: identificationType  numered: identificationNumber ifNone:[^true].	^self error: self class customerIsNotNewErrorDescription.			! !!SupplierImporter methodsFor: 'asserting' stamp: 'PabloFromer 7/2/2018 16:38'!assertValidExistingCustomerRecordSize	record size ~= 3  ifTrue: [ self signalInvalidExistingCustomerRecord ].! !!SupplierImporter methodsFor: 'asserting' stamp: 'PabloFromer 7/2/2018 12:36'!assertValidNewCustomerRecordSize	record size ~= 5  ifTrue: [ self signalInvalidNewCustomerRecord ].! !!SupplierImporter methodsFor: 'asserting' stamp: 'PabloFromer 7/2/2018 12:52'!assertThereIsSupplierForCustomer	^newSupplier isNil ifTrue: [ self error: self class noSupplierForCustomerErrorDescription]	! !!SupplierImporter methodsFor: 'instance creation' stamp: 'MarianoBenzo 7/1/2018 23:13'!newParty	^ newSupplier ! !!SupplierImporter methodsFor: 'importing - private ' stamp: 'PabloFromer 6/29/2018 17:32'!isSupplierRecord	^ record first = 'S'		! !!SupplierImporter methodsFor: 'importing - private ' stamp: 'PabloFromer 7/2/2018 10:47'!importSupplier	self assertValidPartyRecordSize.	newSupplier := Supplier new.	newSupplier fullName: record second.	newSupplier identificationType: record third.	newSupplier identificationNumber: record fourth.	system add: newSupplier! !!SupplierImporter methodsFor: 'importing - private ' stamp: 'PabloFromer 7/2/2018 10:48'!validRecordSize	^ 4! !!SupplierImporter methodsFor: 'importing - private ' stamp: 'PabloFromer 7/2/2018 16:35'!importRecord	self isSupplierRecord ifTrue: [ ^self importSupplier ].	self isAddressRecord ifTrue: [ ^self importAddress ].	self isNewCustomerRecord ifTrue: [ ^self importNewCustomer  ].	self isExistingCustomerRecord ifTrue: [ ^self importExistingCustomer  ].		self signalInvalidRecordType! !!SupplierImporter methodsFor: 'importing - private ' stamp: 'PabloFromer 7/2/2018 17:32'!importExistingCustomer	|customer identificationType identificationNumber|	self assertValidExistingCustomerRecordSize.	self assertThereIsSupplierForCustomer.	identificationType:= record second.	identificationNumber := record third.		customer:= system customerIdentifiedAs: identificationType  numered: identificationNumber   ifNone: [ ^self error: self class customerDoesntExistErrorDescription ]. 			^ newSupplier  addCustomer: customer.		! !!SupplierImporter methodsFor: 'importing - private ' stamp: 'PabloFromer 7/2/2018 17:33'!importNewCustomer	|identificationType identificationNumber|	self assertValidNewCustomerRecordSize.	self assertThereIsSupplierForCustomer.	identificationType:= record fourth.	identificationNumber := record fifth.		self assertCustomerIsNewFor: identificationType with: identificationNumber.		^ newSupplier  addCustomer: self buildCustomer.		! !!SupplierImporter methodsFor: 'importing - private ' stamp: 'PabloFromer 7/2/2018 10:34'!signalAddressWithoutPartyError	self error: self class addressWithoutSupplierErrorDescription.! !!SupplierImporter methodsFor: 'importing - private ' stamp: 'PabloFromer 7/2/2018 12:31'!isNewCustomerRecord	^ record first = 'NC'		! !!SupplierImporter methodsFor: 'signalling' stamp: 'PabloFromer 7/2/2018 10:45'!signalInvalidPartyRecord 		self error: self class invalidSupplierRecordErrorDescription ! !!SupplierImporter methodsFor: 'signalling' stamp: 'PabloFromer 7/2/2018 16:39'!signalInvalidExistingCustomerRecord		self error: self class invalidExistingCustomerRecordErrorDescription ! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!SupplierImporter class	instanceVariableNames: ''!!SupplierImporter class methodsFor: 'signalling' stamp: 'PabloFromer 7/2/2018 16:33'!customerDoesntExistErrorDescription	^'customer doesnt exist'! !!SupplierImporter class methodsFor: 'signalling' stamp: 'PabloFromer 7/2/2018 12:36'!signalInvalidNewCustomerRecord	^'Invalid new customer record'! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'PabloFromer 7/2/2018 16:39'!invalidExistingCustomerRecordErrorDescription		^'invalid existing customer record'! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'PabloFromer 7/2/2018 12:52'!noSupplierForCustomerErrorDescription		^'There is no Supplier for the customer'! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'PabloFromer 7/2/2018 16:12'!customerIsNotNewErrorDescription		^'customer is not new'! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'MarianoBenzo 7/1/2018 20:25'!invalidSupplierRecordErrorDescription	^'Invalid supplier record'! !!SupplierImporter class methodsFor: 'as yet unclassified' stamp: 'MarianoBenzo 7/1/2018 22:51'!addressWithoutSupplierErrorDescription		^'There is no Supplier for the imported address'! !PartySystem subclass: #TransientPartySystem	instanceVariableNames: 'customers suppliers'	classVariableNames: ''	poolDictionaries: ''	category: 'IS1-CustomerImport-Model'!!TransientPartySystem methodsFor: 'setup-teardown' stamp: 'MarianoBenzo 6/27/2018 22:31'!close! !!TransientPartySystem methodsFor: 'setup-teardown' stamp: 'MarianoBenzo 6/27/2018 22:40'!session	^ self! !!TransientPartySystem methodsFor: 'setup-teardown' stamp: 'MarianoBenzo 6/27/2018 22:42'!persist: aCustomer	customers add: aCustomer! !!TransientPartySystem methodsFor: 'initialization' stamp: 'MarianoBenzo 7/1/2018 20:21'!initialize		customers := OrderedCollection new.	suppliers := OrderedCollection new.! !!TransientPartySystem methodsFor: 'initialization' stamp: 'PabloFromer 7/2/2018 16:15'!customerIdentifiedAs: anIdentifycationType numered: anIdentificationNumber ifNone: aBlock		^customers detect: [ :aCustomer | aCustomer isIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ] ifNone: [aBlock value].! !!TransientPartySystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:39'!beginTransaction		! !!TransientPartySystem methodsFor: 'transaction' stamp: 'HernanWilkinson 11/4/2016 09:39'!commit		! !!TransientPartySystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:52'!shutdown		! !!TransientPartySystem methodsFor: 'system live cycle' stamp: 'HernanWilkinson 11/4/2016 09:51'!start	! !!TransientPartySystem methodsFor: 'suppliers' stamp: 'MarianoBenzo 7/1/2018 20:19'!allSuppliers	^ suppliers copy! !!TransientPartySystem methodsFor: 'suppliers' stamp: 'PabloFromer 7/2/2018 13:31'!addSupplier: aSupplier	suppliers add: aSupplier! !!TransientPartySystem methodsFor: 'suppliers' stamp: 'PabloFromer 7/2/2018 13:45'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber		^suppliers detect: [ :aSupplier | aSupplier  isIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ]! !!TransientPartySystem methodsFor: 'suppliers' stamp: 'PabloFromer 7/2/2018 13:46'!supplierIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ifNone: aBlock		^suppliers detect: [ :aSupplier | aSupplier  isIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber ] ifNone: aBlock value.! !!TransientPartySystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:39'!allCustomers	^ customers copy! !!TransientPartySystem methodsFor: 'customers' stamp: 'HernanWilkinson 11/4/2016 09:40'!customersIsEmpty	^ customers isEmpty ! !!TransientPartySystem methodsFor: 'customers' stamp: 'PabloFromer 7/2/2018 13:31'!addCustomer: aCustomer	customers add: aCustomer! !!TransientPartySystem methodsFor: 'customers' stamp: 'PabloFromer 7/2/2018 14:25'!customerIdentifiedAs: anIdentifycationType numbered: anIdentificationNumber		^self customerIdentifiedAs: anIdentifycationType numered: anIdentificationNumber ifNone: [  ]! !!TransientPartySystem methodsFor: 'adding party' stamp: 'PabloFromer 7/2/2018 13:32'!add: aParty	aParty saveOn: self! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 2 July 2018 at 6:36:17.849821 pm'!!String methodsFor: '*IS1-CustomerImport' stamp: 'HernanWilkinson 10/31/2016 23:57'!asPlural		^self last = $s 		ifTrue: [ self, 'es' ]		ifFalse: [ self, 's' ]! !'From Pharo6.0 of 13 May 2016 [Latest update: #60540] on 2 July 2018 at 6:36:17.852821 pm'!!Object methodsFor: '*IS1-CustomerImport' stamp: 'HernanWilkinson 10/31/2016 19:27'!toDo: aString 	! !